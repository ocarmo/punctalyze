"""
Applies cellpose algorithms to determine cellular and nuclear masks
"""

import os
import cv2
import numpy as np
import matplotlib.pyplot as plt
from cellpose import models
from cellpose import plot, utils
from skimage import filters
from skimage.transform import resize
from loguru import logger
from cellpose.io import logger_setup
logger_setup();

logger.info('import ok')

image_folder = 'results/initial_cleanup/'
output_folder = 'results/cellpose_masking/'

if not os.path.exists(output_folder):
    os.mkdir(output_folder)


def apply_cellpose(images, image_type='sam', diameter=None, flow_threshold=0.4, cellprob_threshold=0.0, niter=None, use_gpu=True, big_images=False):
    """apply cellpose to a list of images. Return the masks, flows, and styles generated by the cellpose model.

    Args:
        images (np.array): input images, each image should be a numpy array with shape (channels, height, width).
        image_type (str, optional): Type of cellpose model to use. Defaults to 'sam'.
        diameter (int, optional): Diameter of cells to be detected. Defaults to None.
        flow_threshold (float, optional): Threshold for flow. Defaults to 0.4.
        cellprob_threshold (float, optional): Threshold for cell probability. Defaults to 0.0.
        niter (int, optional): Number of iterations, increase for long cells. Defaults to None.
        use_gpu (bool, optional): Whether or not to use GPU for processing. Defaults to True.
        big_images (bool, optional): Whether or not cells are large (larger than (2000, 2000)). Defaults to False.

    Returns:
        tuple: tuple containing:
            - masks (list): list of masks generated by cellpose.
            - flows (list): list of flow fields generated by cellpose.
            - styles (list): list of styles used by cellpose.

    """
    model = models.CellposeModel(model_type=image_type, gpu=use_gpu)
    images = [img.astype(np.uint16) for img in images]

    if big_images == True:
        # sizes for resizing
        smol_size = (1024, 1024)
        orig_size = images[0].shape[1:]

        # resize
        resized_images = []
        for img in images:
            smol_arrs = []
            for ch in range(0, np.shape(img)[0]):
                smol_arrs.append(resize(img[ch], smol_size, preserve_range=True))
            resized_images.append(smol_arrs)
        images = resized_images

        # apply cellpose to resized images
        masks, flows, styles = model.eval(
            images, diameter=diameter, flow_threshold=flow_threshold, cellprob_threshold=cellprob_threshold, niter=niter)
        
        # resize masks to original size
        resized_masks = []
        for mask in masks:
            resized_mask = []
            for ch in range(0, np.shape(mask)[0]):
                resized_mask.append(resize(mask[ch], orig_size, order=0, preserve_range=True, anti_aliasing=False).astype(int))
            resized_masks.append(resized_mask)
        masks = resized_masks

        # resize flows to original size
        resized_flows = []
        for flow in flows:
            resized_flows.append(cv2.resize(flow[0][0], orig_size))
        flows = resized_flows

    else:
        masks, flows, styles = model.eval(
            images, diameter=diameter, flow_threshold=flow_threshold, cellprob_threshold=cellprob_threshold, niter=niter)

    return masks, flows, styles


def visualise_cell_pose(images, masks, flows, big_images=False):
    """visualise the results of cellpose on a list of images, masks, and flows.

    Args:
        images (list): list of np.array images, each image should be a numpy array with shape (channels, height, width)
        masks (list): list of masks generated by cellpose, each mask should be a numpy array with shape (channels, height, width)
        flows (list): list of flow fields generated by cellpose, each flow should be a numpy array with shape (2, height, width)
        big_images (bool, optional): _description_. Defaults to False.
    """
    for idx, image in enumerate(images):
        fig, ax = plt.subplots(1, 4, figsize=(12, 4))
        ax[0].imshow(image[0], cmap='gray')
        ax[0].set_title("original")

        # plot flow fields
        # flow = flows[idx] if big_images else flows[idx][0][0]
        flow = flows[idx]
        ax[1].imshow(flow)
        ax[1].set_title("flows")

        # outlines
        outlines = utils.outlines_list(masks[idx][0])
        ax[2].imshow(image[0], cmap='gray')
        for o in outlines:
            ax[2].plot(o[:, 0], o[:, 1], color='r')
        ax[2].set_title("outlines")

        # Mask overlay
        ax[3].imshow(plot.mask_overlay(image[0], masks[idx][0]))
        ax[3].set_title("mask overlay")

        plt.tight_layout()
        plt.show()

if __name__ == '__main__':
    
    # ---------------- initialise file list ----------------
    file_list = [filename for filename in os.listdir(
        image_folder) if 'npy' in filename]

    images_dict = {filename.replace('.npy', ''): np.load(
        f'{image_folder}{filename}') for filename in file_list}

    # ---------------- prepare images ----------------
    # Cellpose-SAM will use the first 3 channels of your image, truncating the rest. It has been trained with the cytoplasm and nuclear channels in any order, with the other channel set to zero.
    # you can combine two stains to create your "cytoplasm" channel
    # in this example indices 0 and 1 (1st and 2nd) have two cellular stains, and nuclei are in index 2 (3rd channel)
    imgs_cp = [np.stack((img[[0,1]].sum(axis=0), img[2]), axis=0) for name, img in images_dict.items()]

    # other packages to preprocess images and improve segmentation if needed
    # gaussian_blur = [filters.gaussian(image, sigma=1, multichannel=True) for image in imgs_cp]
    # brightened = [np.clip(channel*5, 0, 65535).astype(np.uint16) for channel in imgs_cp] # assumes 16-bit images

    # ---------------- apply cellpose ----------------
    masks, flows, styles = apply_cellpose(imgs_cp, niter=2000, big_images=True)
    # check the masks with visualisation, else you can skip this step
    visualise_cell_pose(imgs_cp, masks, flows, big_images=True)

    # ---------------- save masks ----------------
    np.save(f'{output_folder}cellpose_cellmasks.npy', masks)
    logger.info('cell masks saved')
